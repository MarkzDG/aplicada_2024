# -*- coding: utf-8 -*-
"""Copia de Clase_Olas_CyD_TLO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j7-nyrRe6O0fnT4SAghUjwUbSGmRp3es
"""

#@title Librerías
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import animation

#@title Relación de dispersion
g=9.81
def dispersion(h,T,x0,ex):
  beta=lambda algo,otro:algo*(2*np.pi/otro)**2/g
  f=lambda x,b: np.tanh(x)-b/x
  df=lambda x,b: (1-np.tanh(x)**2)+b/(x**2)
  be=beta(h,T)
  x1=x0-f(x0,be)/df(x0,be)
  paso=[]
  paso.append(x0)
  while abs(x1-x0)>ex:
    paso.append(x1)
    x0=x1
    x1=x1-f(x1,be)/df(x1,be)
  k=x1/h
  L=2*np.pi/k
  return np.round(L,5)#, paso

"""#Teoría Lineal de Olas (Cinemática y Dinámica)

La TLO nos permite obtener, además de la relación de dispersión, el potencial, la elevación de la superficie libre, el campo de velocidades, aceleraciones, trayectorias y presiones.

##Aproximaciones

$\frac{h}{L}< \frac{1}{20} \Longrightarrow kh<\frac{\pi}{10} \>\>\>\>\>\> \textbf{Aguas poco profundas (APP)} \>\>\>\>\>\> \omega^2=ghk^2$

$\frac{h}{L}> \frac{1}{2} \Longrightarrow kh>\pi \>\>\>\>\>\> \textbf{Aguas profundas (AP)} \>\>\>\>\>\> \omega^2=gk$

$\frac{1}{20} \leq \frac{h}{L} \leq \frac{1}{2} \Longrightarrow \frac{\pi}{10}\leq kh \leq \pi \quad \textbf{Aguas Intermedias (AI)} \quad \omega^2=gk\tanh (kh)$
"""

#@title Veamos una ola de cierto T en distintas profundidades
h=np.array([5,20,100])
T=8
kh_AP=(1/9.8)*(2*np.pi/T)**2*h
L=[]
for ache, ini in zip(h,kh_AP):
  L.append(dispersion(ache,T,ini,0.0001))
H=2
ome=2*np.pi/T
print('Para cada profundidad {h}, la longitud de onda en metros para olas de {T} s es: {L}'.format(h=h,L=np.round(L,2),T=T))
print('Si vemos el valor h/L nos queda: {es}'.format(es=np.round(h/L,3)))

"""## Elevación de superficie libre y potencial

Si consideramos la elevación de la superficie libre:

$\eta (x,t) = \frac{H}{2}\cos (kx - \omega t) $




"""

# Commented out IPython magic to ensure Python compatibility.
#@title Podríamos hacer una animación
# %matplotlib inline
###############
# Primero hacemos los ejes sobre los que irán las figuras
###############
# Definir figura y ejes
fig, axs = plt.subplots(3,1,figsize=(6,8))
for ax in axs.flat:
  ax.set_xlim(( 0, 650))
  ax.set_ylim((-2, 2))
  ax.set_xlabel('x [m]')
  ax.set_ylabel('etha [m]')
  ax.grid(color='grey',linestyle=':')
# Crear objetos que cambiarán durante la animación. Están inicialmente vacíos
# se les deberá dar un valor nuevo por cada frame en la animación
  txt_title = ax.set_title('')
line1, = axs[0].plot([], [], 'b', lw=2,label='$\eta$ con h={h} m'.format(h=h[0]))     # ax.plot returns a list of 2D line objects
line2, = axs[1].plot([], [], 'b', lw=2,label='$\eta$ conh={h} m'.format(h=h[1]))
line3, = axs[2].plot([], [], 'b', lw=2,label='$\eta$ con h={h} m'.format(h=h[2]))
for ax in axs.flat:
  ax.legend(markerscale=0.1)
plt.tight_layout()
plt.close(fig)

#@title seguimos
#######
## Ahora sí, se define la función animación, en dónde deben fijarse los valores
## que tendrán los objetos definidos arriba en cada uno de los frames
# Es llamada secuencialmente
def drawframe(t): # defino tiempo en frames
    x = np.linspace(0, 650, 651)
    l=[]
    y=[]
    for i in [0,1,2]:
        y.append((H/2)*np.cos(2 * np.pi * (x/L[i] - t/T))) #El valor de la linea será la formulación de eta
    line1.set_data(x, y[0])
    txt_title.set_text('Tiempo ={0:4d}'.format(t))
    line2.set_data(x, y[1])
    line3.set_data(x,y[2])
    return (line1,line2,line3)

from matplotlib import animation
#type(l.append)
# blit=True re-draws only the parts that have changed.
anim = animation.FuncAnimation(fig, drawframe, frames=100, interval=200, blit=True)
type(line1)
from IPython.display import HTML
HTML(anim.to_html5_video())

"""La expresión del potencial para la TLO queda entonces:

$\phi (x,z,t) = -\frac{Hg \cosh k(h+z)}{2\omega \cosh(kh)}\sin(kx-\omega t)$

¿Qué pasa con el término $\frac{\cosh k(h+z)}{\cosh(kh)}$?
"""

#@title veamos...
L=np.array(L)
K=2*np.pi/L

fig, ax = plt.subplots(1,3,figsize=(6,4))
for i in range(3):
    Z=np.arange(-h[i],0+h[i]/10,h[i]/10)
    ax[i].plot((1/np.cosh(K[i]*h[i]))*(np.cosh(K[i]*(h[i]+Z))),Z,'b')#,
      #(1/np.sinh(kh[i]))*(np.cosh(K[i]*(h[i]+Z))),Z,'b',
      #(1/np.sinh(kh[i]))*(np.sinh(K[i]*(h[i]+Z))),Z,'g')
    ax[i].set(xlabel=r"$\frac{cosh(k(h+z))}{cosh(kh)}$", ylabel="z (m)", xlim=[0,1])
    ax[i].grid(color='grey',linestyle=':')
    #ax[i].legend([nombre[i]])
plt.tight_layout()

#@title Viendo el potencial
###Podría graficar isolineas de potencial
"""
fig, ax = plt.subplots(1,1,figsize=(9, 4))
X=np.arange(0,L[0]+L[0]/10,L[0]/32)
ax.plot(X,(H/2)*np.cos(K[0]*X-ome*T),'r')
ax.set(ylabel="z(m)", xlabel="x(m)",xlim=[0,L[0]], ylim=[-0.3, 0.3])
ax.grid(color='grey',linestyle=':')
"""
fig, ax = plt.subplots(3,1,figsize=(8, 12))
for i in range(3):
    ZZ=np.arange(-h[i],0+h[i]/10,h[i]/20)
    XX=np.arange(0,L[i]+L[i]/10,L[i]/32)
    X, Z=np.meshgrid(XX,ZZ)
    pot=-(H/2)*(9.81/ome)*(np.cosh(K[i]*(h[i]-Z))/np.cosh(K[i]*h[i]))*np.sin(K[i]*X-ome*T)
    ax[i].contour(X,np.flipud(Z),pot,10,colors='k')
    ax[i].set(ylabel="z(m)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-h[i], 0])
    ax[i].grid(color='grey',linestyle=':')
    #ax[i].legend([nombre[i]])
plt.tight_layout()

"""##Velocidad orbital

$u(x,z,t)=-\frac{\partial \phi}{\partial x}=g \frac{Hk}{2\omega}\frac{\cosh k(h+z)}{\cosh (kh)} \cos (kx-\omega t) = \frac{H\omega}{2}{\frac{\cosh k(h+z)}{\sinh (kh)}} \cos(kx-\omega t) $

$w(x,z,t)=-\frac{\partial \phi}{\partial z}=g \frac{Hk}{2\omega}\frac{\sinh k(h+z)}{\cosh (kh)} \sin (kx-\omega t) = \frac{H\omega}{2}{\frac{\sinh k(h+z)}{\sinh (kh)}} \sin(kx-\omega t) $

¿Qué pasa con los términos $\color{red}{\frac{\cosh k(h+z)}{\sinh(kh)}}$ y $\color{green}{\frac{\sinh k(h+z)}{\sinh(kh)}}$?
"""

#@title Dependencia con Z
fig, ax = plt.subplots(1,3,figsize=(8,6))
for i in range(3):
    Z=np.arange(-h[i],0+h[i]/10,h[i]/10)
    ax[i].plot((1/np.sinh(K[i]*h[i]))*(np.cosh(K[i]*(h[i]+Z))),Z,'r',label='u')#label=r"$\frac{\cosh(k(h+z))}{\sinh(kh)}$")
    ax[i].plot((1/np.sinh(K[i]*h[i]))*(np.sinh(K[i]*(h[i]+Z))),Z,'g',label='w')#r"$\frac{sinh(k(h+z))}{sinh(kh)}$")
    ax[i].set(ylabel="Z (m)")
    ax[i].grid(color='grey',linestyle=':')
    ax[i].legend(bbox_to_anchor =(0.65, -0.10))
plt.tight_layout()

#@title Funcion para las velocidades **veloci(h,H,k,ome,x,z,t)**
def veloci(h,H,k,ome,x,z,t):
    U=(H/2)*(ome)*np.cosh(k*(h+z))*np.cos(k*x-ome*t)/np.sinh(k*h)
    W=(H/2)*(ome)*np.sinh(k*(h+z))*np.sin(k*x-ome*t)/np.sinh(k*h)
    return U,W

#@title Campo de velocidades
fig, ax = plt.subplots(3,1,figsize=(9, 6))
for i in range(3):
    ZZ=np.arange(-h[i],0+h[i]/10,h[i]/10)
    XX=np.arange(0,L[i]+L[i]/10,L[i]/16)
    X, Z=np.meshgrid(XX,ZZ)
    U,W=veloci(h[i],H,K[i],ome,X,Z,0)
    ax[i].quiver(X,Z,U,W)
    #ax[0].plot((H/2)*np.cos(K[0]*np.linspace(0,L[0],L[0]/16)),'r')
    ax[i].set(ylabel="z(m)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-h[i], 2])
    ax[i].grid(color='grey',linestyle=':')
    #ax[i].legend([nombre[i]])
plt.tight_layout()

#@title Otro gráfico de velocidades
##Pruebo otra manera de hacer subplots
H=0.5
import matplotlib.gridspec as gridspec
fig = plt.figure(figsize=(9, 9))
gs = gridspec.GridSpec(nrows=3, ncols=3)
for i in range(3):
    ZZ=np.arange(-h[i],0+h[i]/10,h[i]/10)
    XX=np.arange(0,L[i]+L[i]/8,L[i]/16)
    etha=(H/2)*np.cos(K[i]*XX-ome*(T/2))
    U0,W0=veloci(h[i],H,K[i],ome,XX,0,T/2)
    U1,W1=veloci(h[i],H,K[i],ome,XX,-h[i]/2,T/2)
    U2,W2=veloci(h[i],H,K[i],ome,XX,-h[i],T/2)
    ax0=fig.add_subplot(gs[0,i])
    ax0.plot(XX,etha,':k')
    ax0.set(ylabel="etha (m)", xlabel="x(m)",xlim=[0,L[i]])
    ax1=ax0.twinx()
    ax1.plot(XX,U0,XX,W0)
    ax1.text(L[i]/2,0.1,'z = 0')
    ax1.legend(['U', 'W'])
    ax1.set(xlabel="x(m)",xlim=[0,L[i]], ylim=[-0.4,0.4])
    ax0.grid(color='grey',linestyle=':')
    ax2=fig.add_subplot(gs[1,i])
    ax2.plot(XX,U1,XX,W1)
    ax2.text(L[i]/2,0.1,'z = -h/2')
    ax2.set(ylabel="U,W (m/s)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-0.4,0.4])
    ax2.grid(color='grey',linestyle=':')
    ax3=fig.add_subplot(gs[2,i])
    ax3.plot(XX,U2,XX,W2)
    ax3.set(ylabel="U,W (m/s)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-0.4,0.4])
    ax3.text(L[i]/2,0.1,'z = -h')
    ax3.grid(color='grey',linestyle=':')
plt.tight_layout()

"""##Aceleración de las partículas

$a_{x} = \frac{H}{2} \omega ^2 \frac{\cosh k(h+z)}{\sinh (kh)} \sin (kx-\omega t)$


$a_{z} = \frac{H}{2} \omega ^2 \frac{\sinh k(h+z)}{\sinh (kh)} \cos (kx-\omega t)$

##Trayectoria de las partículas

$\frac{\zeta ^2}{A^2}+\frac{\xi ^2}{B^2}=1$

con:

$A=\frac{H}{2}\frac{\cosh k(h+z_{1})}{\sinh (kh)}$

$B=\frac{H}{2}\frac{\sinh k(h+z_{1})}{\sinh (kh)}$

## **Presión bajo olas progresivas**

$P = -\rho g z + \rho g \frac{H \cosh k(h+z)}{2\cosh (kh)}\cos (kx - \omega t)$

Puede escribirse en función de $\eta = \cos (kx - \omega t)$ y $K_{p}=\frac{\cosh k(h+z)}{\cosh (kh)}$:

$P = -\rho g z + \rho g \eta K_{p} (z)$
"""

#@title Campo de presión bajo las olas en cada h/L
rho=1024
g=9.81
fig, ax = plt.subplots(1,1,figsize=(7, 2))
X=np.arange(0,L[0]+L[0]/10,L[0]/32)
ax.plot(X,(H/2)*np.cos(K[0]*X-ome*T),'b',lw=3)
ax.set(ylabel="z(m)",xlim=[0,L[0]], ylim=[-0.3, 0.3],xticklabels=[])
ax.text(1.07,0.5,r'$\eta$ ',fontsize=16,bbox=dict(facecolor='grey', alpha=0.5),transform=ax.transAxes)
ax.grid(color='grey',linestyle=':')
plt.tight_layout()
fig, ax = plt.subplots(3,1,figsize=(8, 9))
for i in range(3):
    ZZ=np.arange(-h[i],0+h[i]/10,h[i]/20)
    XX=np.arange(0,L[i]+L[i]/10,L[i]/32)
    X, Z=np.meshgrid(XX,ZZ)
    pre=-rho*g*Z+rho*g*(H/2)*(np.cosh(K[i]*(h[i]-Z))/np.cosh(K[i]*h[i]))*np.cos(K[i]*X-ome*T)
    pred=rho*g*(H/2)*(np.cosh(K[i]*(h[i]-Z))/np.cosh(K[i]*h[i]))*np.cos(K[i]*X-ome*T)
    CS=ax[i].contour(X,np.flipud(Z),pre,10,colors='k')
    ax[i].clabel(CS, inline=True, fontsize=10)
    ax[i].contour(X,np.flipud(Z),pred,10,colors='grey')
    ax[i].set(ylabel="z(m)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-h[i], 0])
    ax[i].grid(color='grey',linestyle=':')
    ax[i].text(1.1,0.5,r'$\frac{h}{L}$='+str(np.round(h[i]/L[i],3)),fontsize=16,bbox=dict(facecolor='grey', alpha=0.5),transform=ax[i].transAxes)
plt.tight_layout()

#@title La parte dinámica.
fig, ax = plt.subplots(3,1,figsize=(8, 12))
for i in range(3):
    ZZ=np.arange(-h[i],0+h[i]/10,h[i]/20)
    XX=np.arange(0,L[i]+L[i]/10,L[i]/32)
    X, Z=np.meshgrid(XX,ZZ)
    pre=rho*g*(H/2)*(np.cosh(K[i]*(h[i]-Z))/np.cosh(K[i]*h[i]))*np.cos(K[i]*X-ome*T)
    ax[i].contour(X,np.flipud(Z),pre,10,colors='k')
    ax[i].set(ylabel="z(m)", xlabel="x(m)",xlim=[0,L[i]], ylim=[-h[i], 0])
    ax[i].grid(color='grey',linestyle=':')
    #ax[i].legend([nombre[i]])
plt.tight_layout()